#' @export
scoreEstimation_v2 <- function (obs, anis_list, weightFun = NULL, dWeightFun = NULL,
          nCores = 1L, cl = NULL,compos_like_index_list = NULL, ...)
{
  ellipsis <- list(...)
  if ("weigthFun" %in% names(ellipsis) && is.null(weightFun)) {
    weightFun <- ellipsis[["weigthFun"]]
    ellipsis[["weigthFun"]] <- NULL
  }
  if ("dWeigthFun" %in% names(ellipsis) && is.null(dWeightFun)) {
    dWeightFun <- ellipsis[["dWeigthFun"]]
    ellipsis[["dWeigthFun"]] <- NULL
  }
  if (is.null(weightFun)) {
    stop("`weightFun` argument missing, with no default value.")
  }
  if (is.null(dWeightFun)) {
    stop("`dWeightFun` argument missing, with no default value.")
  }
  if (class(obs) != "list" || length(obs) < 1 || class(obs[[1]]) !=
      "numeric") {
    stop("`obs` must be a list of vectors.")
  }
  # if (class(loc) != "data.frame") {
  #   stop("`loc` must be the data frame of coordinates as generated by expand.grid().")
  # }
  if (class(weightFun) != "function") {
    stop("`weightFun` must be a function.")
  }
  if (class(dWeightFun) != "function") {
    stop("`dWeightFun` must be a function.")
  }
  if (class(compos_like_index_list) != "list") {
    stop("`compos_like_index_list` must be a list.")
  }
  if (!is.numeric(nCores) || nCores < 1) {
    stop("`nCores` must a positive number of cores.")
  }
  if (nCores > 1 && length(grep("cluster", class(cl))) ==
      0) {
    stop("For parallel computation, `cl` must an cluster created by `makeCluster` of the package parallel.")
  }

  require(Matrix)

  attach(anis_list)
  H_11 <- compute_A_H_11(coordinates_H_11_x_right,
                         coordinates_H_11_x_left,
                         coordinates_H_11_y,
                         sign_H_11,
                         anisVector_1,
                         diagH)
  H_22 <- compute_A_H_22(coordinates_H_22_x,
                         coordinates_H_22_y_top,
                         coordinates_H_22_y_bot,
                         sign_H_22,
                         anisVector_2,
                         diagH)
  H_12 <- compute_A_H_12(coordinates_H_12_x,
                         coordinates_H_12_y_top,
                         coordinates_H_12_y_bot,
                         sign_H_12_top,
                         sign_H_12_bot,
                         anisVector_1,
                         anisVector_2,
                         diagH)
  H_21 <- compute_A_H_21(coordinates_H_21_x_right,
                         coordinates_H_21_x_left,
                         coordinates_H_21_y,
                         sign_H_21_right,
                         sign_H_21_left,
                         anisVector_1,
                         anisVector_2,
                         diagH)

  ######## COMPUTE PRECISION MATRIX #########
  A_H <- (h_y / h_x) * H_11 + (h_x / h_y) * H_22 + 1 / 4  * (H_12 + H_21)  # i don't get why there are h_x,h_y coefficients
  matrix_A <- D_V %*% diagKappa(D_i,D_j) - A_H #D_V = I * V with V=h_x*h_y, its the area of each square
  precisionMatrix_Q <- Matrix::t(matrix_A) %*% D_V_inv %*% matrix_A



  covarianceMatrix  <-  solve(precisionMatrix_Q) 


  if(! is.null(restriction_indices)){
    covarianceMatrix <- as.matrix(covarianceMatrix[restriction_indices,restriction_indices])
  }

  detach(anis_list)

  Loc_set_score <- function(index_set,ellipsis=ellipsis,obs=obs,covarianceMatrix=covarianceMatrix){
    require(Matrix)

    obs <- lapply(obs, function(elem){elem[index_set]})

    weight_coeff <- ellipsis$weight_coeff
    r_func_vec <- ellipsis$r_func_vec[index_set]

    n <- length(obs)

    SigmaS <- covarianceMatrix[index_set,index_set] #The covariance matrix is shrunk to the smaller set of indices
    sigmaInv <- solve(SigmaS)
  
    #####################Here we we follow Eq. S3 in Supplementary material from de Fondeville 2018
    sigma <- diag(SigmaS)
    q <- rowSums(sigmaInv) ######This is pho in equation S3
    A <- sigmaInv - q %*% t(q)/sum(q) ##########This is Gamma in eq. S3
    #zeroDiagA <- A
    #diag(zeroDiagA) <- 0
    mtp <- 2 * q/(sum(q)) + 2 + sigmaInv %*% sigma - (q %*% t(q) %*%
                                                        sigma)/(sum(q)) 
    computeScores = function(i) {
      gradient <- -1/2 * ((A + t(A)) %*% log(obs[[i]])) * (1/obs[[i]]) -
        1/2 * (1/obs[[i]]) * mtp
      diagHessian <- -1/2 * diag(A + t(A)) * (1/obs[[i]]^2) +
        1/2 * ((A + t(A)) %*% log(obs[[i]])) * (1/obs[[i]])^2 +
        1/2 * (1/obs[[i]])^2 * mtp
      weights <- weightFun(weight_coeff = weight_coeff,
                            r_func_vec = r_func_vec,
                            x = obs[[i]])
      dWeights <- dWeightFun(weight_coeff = weight_coeff,
                            r_func_vec = r_func_vec,
                            x = obs[[i]])
      sum(2 * (weights * dWeights) * gradient + weights^2 *
            diagHessian + 1/2 * weights^2 * gradient^2)
    }

    scores <- lapply(1:n, computeScores)

    return(sum(unlist(scores))/n)
  }


  if (nCores > 1) {
    scores <- parallel::parLapply(cl, compos_like_index_list, Loc_set_score,ellipsis=ellipsis,obs=obs,covarianceMatrix=covarianceMatrix)
  }
  else{
    scores <- lapply(compos_like_index_list, Loc_set_score,ellipsis=ellipsis,obs=obs,covarianceMatrix=covarianceMatrix)
  }
  return(sum(unlist(scores))/length(compos_like_index_list))
}
